/* * Copyright (c) 2015 Samsung Electronics Co., Ltd. All rights reserved.  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that  * the following conditions are met: *  *     * Redistributions of source code must retain the above copyright notice,  *       this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above copyright notice,  *       this list of conditions and the following disclaimer in the documentation and/or  *       other materials provided with the distribution.  *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its contributors may be used to endorse or  *       promote products derived from this software without specific prior written permission. *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */package com.samsung.android.sdk.accessory.example.galleryconsumer;import java.util.List;import android.app.Activity;import android.app.AlertDialog;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Bundle;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.util.Base64;import android.util.Log;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.ImageView;import android.widget.LinearLayout;import android.widget.TextView;import android.widget.Toast;import com.samsung.android.sdk.accessory.example.galleryconsumer.GalleryConsumerService.ImageListReceiver;import com.samsung.android.sdk.accessory.example.galleryconsumer.GalleryConsumerService.LocalBinder;import com.samsung.android.sdk.accessory.*;public class GalleryConsumerActivity extends Activity implements OnClickListener, ImageListReceiver {    public static final int MSG_INITIATE_CONNECTION = 6;    public static final int MSG_THUMBNAIL_RECEIVED = 1986;    public static final int MSG_IMAGE_RECEIVED = 1987;    public static final int INITIAL_IMAGE_INDEX = -1;    private static final String TAG = "GalleryConsumerActivity";    int mNextIndex = INITIAL_IMAGE_INDEX;    int mIndextb1 = INITIAL_IMAGE_INDEX;    int mIndextb2 = INITIAL_IMAGE_INDEX;    int mIndextb3 = INITIAL_IMAGE_INDEX;    GalleryConsumerService mBackendService = null;    List<ImageStructure> mDTBListReceived = null;    ImageStructure mImage = null;    String mDownscaledImage = "";    boolean mIsBound = false;    boolean mReConnect = false;    Button mFetch;    Button mNext;    Button mConnect;    Button mClose;    ImageView mTb1;    ImageView mTb2;    ImageView mTb3;    TextView mTxt1;    TextView mTxt2;    TextView mTxt3;    Handler mHandler = new Handler(new ImageReceivedHandlerCallback()) {    };    private static Object mListLock = new Object();    private ServiceConnection mConnection = new ServiceConnection() {        public void onServiceConnected(ComponentName className, IBinder service) {            LocalBinder binder = (LocalBinder) service;            mBackendService = binder.getService();            mBackendService.registerImageReciever(GalleryConsumerActivity.this);            mIsBound = true;            mBackendService.findPeers();        }        public void onServiceDisconnected(ComponentName className) {            Log.e(TAG, "Gallery Service Disconnected");            mBackendService = null;            mIsBound = false;        }    };    @Override    protected void onResume() {        if (mReConnect == true && mBackendService != null) {            mBackendService.findPeers();        }        super.onResume();    }    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        // Bind to the consumer service on create itself        doBindServiceToConsumerService();        mFetch = (Button) findViewById(R.id.btnFetch);        mFetch.setOnClickListener(this);        mNext = (Button) findViewById(R.id.btnNext);        mNext.setOnClickListener(this);        mConnect = (Button) findViewById(R.id.btnConnect);        mConnect.setOnClickListener(this);        mClose = (Button) findViewById(R.id.btnClose);        mClose.setOnClickListener(this);        mTb1 = (ImageView) findViewById(R.id.imageView1);        mTb1.setOnClickListener(this);        mTb2 = (ImageView) findViewById(R.id.imageView2);        mTb2.setOnClickListener(this);        mTb3 = (ImageView) findViewById(R.id.imageView3);        mTb3.setOnClickListener(this);        mTxt1 = (TextView) findViewById(R.id.textView1);        mTxt1.setOnClickListener(this);        mTxt2 = (TextView) findViewById(R.id.textView2);        mTxt2.setOnClickListener(this);        mTxt3 = (TextView) findViewById(R.id.textView3);        mTxt3.setOnClickListener(this);    }    protected void onDestroy() {        Log.i(TAG, "onDestroy");        closeConnection();        doUnbindService();        super.onDestroy();    }    @Override    public void onClick(View v) {        switch (v.getId()) {            case R.id.btnConnect: {                if (mIsBound) {                    mBackendService.findPeers();                }            }                break;            case R.id.btnFetch: {                if (mIsBound) {                    requestThumbnails();                }            }                break;            case R.id.btnNext: {                if (mIsBound) {                    requestNext();                }            }                break;            case R.id.btnClose: {                if (mIsBound) {                    closeConnection();                }                clearThumbnails();                mNextIndex = INITIAL_IMAGE_INDEX;            }                break;            case R.id.imageView1: {                requestImage(mIndextb1);            }                break;            case R.id.imageView2: {                requestImage(mIndextb2);            }                break;            case R.id.imageView3: {                requestImage(mIndextb3);            }                break;            default:        }    }    public void onImageReceived(ImageStructure img) {        mImage = img;        Message msg = Message.obtain();        msg.what = MSG_IMAGE_RECEIVED;        mHandler.sendMessage(msg);    }    @Override    public void onThumbnailsReceived(List<ImageStructure> uListReceived) {        synchronized (mListLock) {            // consumer can use this list to hold previous thumbnails as cache            Log.d(TAG, "onThumbnailsReceived Enter");            mDTBListReceived = uListReceived;            Message msg = Message.obtain();            msg.what = MSG_THUMBNAIL_RECEIVED;            mHandler.sendMessage(msg);        }    }    @Override    public void onPeerFound(SAPeerAgent uRemoteAgent) {        if (uRemoteAgent != null) {            if (mIsBound = true) {                mBackendService.establishConnection(uRemoteAgent);            }        } else {            Toast.makeText(getApplicationContext(), R.string.NoPeersFound, Toast.LENGTH_LONG).show();        }    }    @Override    public void onServiceConnectionResponse(int result) {        if (result == SAAgent.CONNECTION_SUCCESS) {            Toast.makeText(getApplicationContext(), R.string.ConnectionEstablishedMsg, Toast.LENGTH_LONG).show();//            mHandler.post(new Runnable() {//                @Override//                public void run() {//                    Toast.makeText(getBaseContext(), R.string.ConnectionEstablishedMsg, Toast.LENGTH_SHORT).show();//                }//            });        }    }    @Override    public void onServiceConnectionLost(int errorcode) {        if (errorcode == SASocket.CONNECTION_LOST_DEVICE_DETACHED)            mReConnect = true;        mHandler.post(new Runnable() {            @Override            public void run() {                Toast.makeText(getBaseContext(), R.string.ConnectionLostMsg, Toast.LENGTH_SHORT).show();            }        });    }    @Override    public void onThumbnailsPush() {        if (mIsBound) {            requestThumbnails();        }    }    @Override    public void onThumbnailsNext() {        if (mIsBound) {            requestNext();        }    }    void doBindServiceToConsumerService() {        mIsBound = bindService(new Intent(this, GalleryConsumerService.class), mConnection, Context.BIND_AUTO_CREATE);    }    void doUnbindService() {        if (mIsBound == true) {            unbindService(mConnection);            mIsBound = false;        }    }    void closeConnection() {        if (mIsBound == true) {            mBackendService.closeConnection();        }    }    private void requestThumbnails() {        mBackendService.requestThumbNail(INITIAL_IMAGE_INDEX);        mNextIndex = INITIAL_IMAGE_INDEX;    }    private void requestNext() {        if (mNextIndex != -1)            mBackendService.requestThumbNail(mNextIndex);        else            requestThumbnails();    }    private void requestImage(int index) {        if (index != INITIAL_IMAGE_INDEX) {            mBackendService.requestImage(index);        }    }    private void clearThumbnails() {        mIndextb1 = INITIAL_IMAGE_INDEX;        mIndextb2 = INITIAL_IMAGE_INDEX;        mIndextb3 = INITIAL_IMAGE_INDEX;        mTb1.setImageResource(R.drawable.ic_launcher);        mTb2.setImageResource(R.drawable.ic_launcher);        mTb3.setImageResource(R.drawable.ic_launcher);        mTxt1.setText(" ");        mTxt2.setText(" ");        mTxt3.setText(" ");    }    private boolean handleRecievedImage() {        // parse the structure and render on Image VIEW        mDownscaledImage = mImage.mData;        byte[] decodedstream;        try        {            decodedstream = Base64.decode(mDownscaledImage, Base64.NO_WRAP);        } catch(IllegalArgumentException e) {            Log.e(TAG, "handleReceivedThumbnails: mDownscaledImage "+mDownscaledImage);            Log.e(TAG, "handleReceivedThumbnails decode failed "+e.getMessage());            return false;        }        Bitmap bitmap = BitmapFactory.decodeByteArray(decodedstream, 0, decodedstream.length);        // try new full screen approach        final AlertDialog.Builder thumbDialog = new AlertDialog.Builder(GalleryConsumerActivity.this);        ImageView thumbView = new ImageView(GalleryConsumerActivity.this);        thumbView.setMinimumWidth(320);        thumbView.setMinimumWidth(240);        thumbView.setBackgroundResource(00000000);        if (bitmap != null) {            thumbView.setImageBitmap(bitmap);        }        LinearLayout layout = new LinearLayout(GalleryConsumerActivity.this);        layout.setOrientation(LinearLayout.VERTICAL);        layout.addView(thumbView);        thumbDialog.setView(layout);        thumbDialog.show();        Toast.makeText(getApplicationContext(), mImage.mDisplayname, Toast.LENGTH_LONG).show();        return true;    }    private boolean handleReceivedThumbnails() {        synchronized (mListLock) {            int size = mDTBListReceived.size();            if (!mDTBListReceived.isEmpty()) {                // last elements id for reference                try {                    mNextIndex = Integer.parseInt(mDTBListReceived.get(size - 1).mId);                } catch (IndexOutOfBoundsException e) {                    e.printStackTrace();                }                while (size > 0) {                    ImageStructure thb1 = mDTBListReceived.get(size - 1);                    byte[] decodedstream;                    try                    {                        decodedstream = Base64.decode(thb1.mData, Base64.NO_WRAP);                    } catch(IllegalArgumentException e) {                        Log.e(TAG, "handleReceivedThumbnails: mData "+thb1.mData);                        Log.e(TAG, "handleReceivedThumbnails decode failed "+e.getMessage());                        return false;                    }                    Bitmap bitmap = BitmapFactory.decodeByteArray(                                decodedstream, 0, decodedstream.length);                    if (bitmap != null) {                        switch (size) {                            case 3: {                                mTb1.setImageBitmap(bitmap);                                mIndextb1 = Integer.parseInt(thb1.mId);                                mTxt1.setText(thb1.mDisplayname);                            }                                break;                            case 2: {                                mTb2.setImageBitmap(bitmap);                                mIndextb2 = Integer.parseInt(thb1.mId);                                mTxt2.setText(thb1.mDisplayname);                            }                                break;                            case 1: {                                mTb3.setImageBitmap(bitmap);                                mIndextb3 = Integer.parseInt(thb1.mId);                                mTxt3.setText(thb1.mDisplayname);                            }                                break;                        }                    }                    size--;                }            }            return true;        }    }    class ImageReceivedHandlerCallback implements Handler.Callback {        @Override        public boolean handleMessage(Message msg) {            if (msg.what == MSG_THUMBNAIL_RECEIVED) {                clearThumbnails();                handleReceivedThumbnails();            } else if (msg.what == MSG_IMAGE_RECEIVED) {                handleRecievedImage();            }            return true;        }    }}